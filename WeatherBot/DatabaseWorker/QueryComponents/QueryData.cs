using System;
using System.Collections.Generic;
using System.Runtime.Serialization;

namespace WeatherBot.DatabaseWorker.QueryComponents {

    [DataContract]
    public class QueryData {

        [DataMember]
        public int InitiatorId;

        [DataMember]
        public string City;

        [DataMember]
        public Dictionary<DateTime, WeatherEntities> weatherAtTimes;
    }
}


    // Нарушается логика работы с данными. Запрос и разбор данных из базы спланирован в слое IOFilter.
    
    // При такой реализации мы получаем двойную упаковку-распаковку и преобразования из структуры в структуру. 
    // При таком дата-контракте мы получаем формирование структуры в слое IOFilter, служба базы снова разбирает структуру, 
    // пытается понять к какому времени суток относится то или иное время, упаковывает обратно, слой IO обратно 
    // разбирает и преобразовыает к конечному виду данные. Т.е. в службе базы нужно реализовывать еще один слой. 
    
    // База - ничего не знает о данных, она их просто хранит. И возвращает по запросу. Коллектор погоды - ничего не знает 
    // о погоде, он разбирает структуры и распихивает по базе. 
    // На данном этапе решено было не парсить почасовые данные, так как и без этого сложная структура БД.
    // В дальнейшем при реализации сбора почасовых данных придется переписывать всю логику выборки из БД, а это не тру.
    
    // Нам параллельно сколько данных передается, т.к. самое большое время займет установка соединения между сервисами.
    // Данные передаются между сервисами, но - эти сервисы на одном одной машине, вся передача будет заключаться 
    // в изменении адресного пространства в оперативной памяти. 

    // Можно реализовать и такой дата контракт. Но надо реализовывать доп. слой между IOFilter и базой, но при изменении структруры БД
    // придется изменять логику работы этого слоя.


    // - jekakmail




/*
    Почему структура запроса должна быть такой, аргументы:

    ---

    string QueryData.City;

    Город в составе запроса должен быть один т.к. несколько городов в одном запросе будут присутствовать не часто.
    Но такую возможность тоже можно поддержать, "распарсится" на два запроса для разных городов. т.е. Будет просто
    два QueryData для одного InitiatorId.

    ---

    Dictionary<DateTime, WeatherEntities> weatherAtTimes;

    Для конкретного времени либо частей дня (утро, день, вечер, ночь), а так же самих дней, месяцев, годов и пр.
    достаточно переменной DateTime, не нужно никаких лишних структур и типов. В базе могут быть какие угодно структуры,
    в запросе - чем проще и легче (по "весу"), тем лучше и быстрее. Т.к. ими придётся перекидываться между сервисами.

    Если пользователю нужен какой-то временной интервал - этих DateTime может быть несколько, например:
    
    утро, день, вечер, ночь - в DateTime 06:00, 12:00, 18:00, 00:00
    вчера, сегодня, завтра  - в DateTime 27.04.2016 - 12:00, 28.04.2016 - 12:00, 29.04.2016 - 12:00
    
    по такому же принципу заполняются запросы вида: "месяц назад на неделю" или "послезавтра весь день",
    или "в субботу, после обеда" и все остальные.

    WeatherEntities - простая структура со всеми возможными погодными данными в запрошенное время, т.е.
    Dictionary<DateTime, WeatherEntities> weatherAtTimes; ни что иное как список пар вида: ВРЕМЯ и ПОГОДА в это время.
    
    Всё, ничего лишнего )

    - Art.Stea1th
*/
